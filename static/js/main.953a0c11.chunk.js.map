{"version":3,"sources":["P5Wrapper/index.js","sketches/sketch.js","App.js","index.js"],"names":["P5Wrapper","props","_this","Object","classCallCheck","this","possibleConstructorReturn","getPrototypeOf","call","wrapper","React","createRef","canva","p5","sketch","current","customCallbackHandler","callback","customRedrawHandler","values","prevProps","remove","canvas","react_default","a","createElement","ref","Component","p","isSearching","currnetGridSize","newGridSize","currentWallFrequency","newWallFrequency","squareSize","Grid","gridSize","wallFrequency","createNodes","x","grid","Array","y","Node","start","end","wall","displayNodes","showNode","setNodesNeighbors","i","Math","max","min","j","neighbors","push","openSet","closedSet","optimalPath","_this2","noStroke","fill","isInOpenSet","color","isInClosedSet","isOptimalPath","rect","size","random","f","g","h","partent","undefined","heuristic","b","D2","sqrt","dx","abs","dy","setup","createCanvas","draw","background","isDone","length","message","bestFScoreIndex","currentNode","filter","value","index","temporalNode","includes","temporaryGScore","isPathBetter","App","gridSizeChange","event","setState","target","wallFrequencyChange","toggleSearch","state","stateChange","newState","stateSketch","src_P5Wrapper","type","defaultValue","step","onInput","onClick","disabled","ReactDOM","render","src_App","document","getElementById"],"mappings":"oNAqCeA,cAjCb,SAAAA,EAAYC,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAAL,IACjBE,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAAH,GAAAQ,KAAAH,KAAMJ,KACDQ,QAAUC,IAAMC,YAFJT,mFAMjBG,KAAKO,MAAQ,IAAIC,IAAGR,KAAKJ,MAAMa,OAAQT,KAAKI,QAAQM,SACpDV,KAAKO,MAAMI,sBAAwBX,KAAKJ,MAAMgB,SAC1CZ,KAAKO,MAAMM,qBACbb,KAAKO,MAAMM,oBAAoBb,KAAKJ,MAAMkB,mDAI3BC,GACbf,KAAKJ,MAAMa,SAAWM,EAAUN,SAClCT,KAAKO,MAAMS,SACXhB,KAAKiB,OAAS,IAAIT,IAAGR,KAAKJ,MAAMa,OAAQT,KAAKI,SAC7CJ,KAAKO,MAAMI,sBAAwBX,KAAKJ,MAAMgB,UAE5CZ,KAAKO,MAAMM,qBACbb,KAAKO,MAAMM,oBAAoBb,KAAKJ,MAAMkB,uDAK5Cd,KAAKO,MAAMS,0CAIX,OAAOE,EAAAC,EAAAC,cAAA,OAAKC,IAAKrB,KAAKI,iBA9BFkB,aCHT,SAASb,EAAOc,GAE7B,IAGIC,GAAc,EAIdC,EADkB,GAElBC,EAAc,EAIdC,EADuB,GAEvBC,EAAmB,EAGnBC,EAhBa,IAgBaJ,EAGxBK,EACJ,SAAAA,EAAYC,EAAUF,EAAYG,GAAe,IAAAnC,EAAAG,KAAAF,OAAAC,EAAA,EAAAD,CAAAE,KAAA8B,GAAA9B,KAcjDiC,YAAc,WACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIrC,EAAKkC,SAAUG,IACjCrC,EAAKsC,KAAKD,GAAK,IAAIE,MAAMvC,EAAKkC,UAGhC,IAAK,IAAIG,EAAI,EAAGA,EAAIrC,EAAKkC,SAAUG,IACjC,IAAK,IAAIG,EAAI,EAAGA,EAAIxC,EAAKkC,SAAUM,IACjCxC,EAAKsC,KAAKD,GAAGG,GAAK,IAAIC,EAAKJ,EAAGG,EAAGxC,EAAKgC,WAAYhC,EAAKmC,eAI3DnC,EAAK0C,MAAQ1C,EAAKsC,KAAK,GAAG,GAC1BtC,EAAK2C,IAAM3C,EAAKsC,KAAKtC,EAAKkC,SAAW,GAAGlC,EAAKkC,SAAW,GAExDlC,EAAK0C,MAAME,KAAO,EAClB5C,EAAK2C,IAAIC,KAAO,GA7B+BzC,KAiCjD0C,aAAe,WACb,IAAK,IAAIR,EAAI,EAAGA,EAAIrC,EAAKkC,SAAUG,IACjC,IAAK,IAAIG,EAAI,EAAGA,EAAIxC,EAAKkC,SAAUM,IACjCxC,EAAKsC,KAAKD,GAAGG,GAAGM,YApC2B3C,KA0CjD4C,kBAAoB,WAClB,IAAK,IAAIV,EAAI,EAAGA,EAAIrC,EAAKkC,SAAUG,IACjC,IAAK,IAAIG,EAAI,EAAGA,EAAIxC,EAAKkC,SAAUM,IACjC,IAAKxC,EAAKsC,KAAKD,GAAGG,GAAGI,KACnB,IACE,IAAII,EAAIC,KAAKC,IAAI,EAAGb,EAAI,GACxBW,GAAKC,KAAKE,IAAId,EAAI,EAAGrC,EAAKkC,SAAW,GACrCc,IAEA,IACE,IAAII,EAAIH,KAAKC,IAAI,EAAGV,EAAI,GACxBY,GAAKH,KAAKE,IAAIX,EAAI,EAAGxC,EAAKkC,SAAW,GACrCkB,IAEIJ,IAAMX,GAAKe,IAAMZ,GACdxC,EAAKsC,KAAKU,GAAGI,GAAGR,MACnB5C,EAAKsC,KAAKD,GAAGG,GAAGa,UAAUC,KAAKtD,EAAKsC,KAAKU,GAAGI,KAzD1DjD,KAAK+B,SAAWA,EAChB/B,KAAK6B,WAAaA,EAClB7B,KAAKgC,cAAgBA,EAErBhC,KAAKmC,KAAO,IAAIC,MAAML,GAGtB/B,KAAKoD,QAAU,GACfpD,KAAKqD,UAAY,GACjBrD,KAAKsD,YAAc,IA4DjBhB,EACJ,SAAAA,EAAYJ,EAAGG,EAAGR,EAAYG,GAAe,IAAAuB,EAAAvD,KAAAF,OAAAC,EAAA,EAAAD,CAAAE,KAAAsC,GAAAtC,KAkC7C2C,SAAW,WACTpB,EAAEiC,WACFjC,EAAEkC,KAAK,KAEHF,EAAKd,MACPlB,EAAEkC,KAAK,IAGLF,EAAKG,aACPnC,EAAEkC,KAAKlC,EAAEoC,MAAM,EAAG,IAAK,EAAG,KAGxBJ,EAAKK,eACPrC,EAAEkC,KAAKlC,EAAEoC,MAAM,IAAK,EAAG,EAAG,KAGxBJ,EAAKM,eACPtC,EAAEkC,KAAKlC,EAAEoC,MAAM,EAAG,EAAG,IAAK,KAG5BpC,EAAEuC,KACAP,EAAKrB,EAAIqB,EAAKQ,KACdR,EAAKlB,EAAIkB,EAAKQ,KACdR,EAAKQ,KAAO,EACZR,EAAKQ,KAAO,IAxDd/D,KAAK+D,KAAOlC,EAGZ7B,KAAKkC,EAAIA,EACTlC,KAAKqC,EAAIA,EAGTrC,KAAKyC,MAAO,EAGRK,KAAKkB,SAAWhC,IAClBhC,KAAKyC,MAAO,GAIdzC,KAAKiE,EAAI,EACTjE,KAAKkE,EAAI,EACTlE,KAAKmE,EAAI,EAGTnE,KAAKkD,UAAY,GAGjBlD,KAAKoE,aAAUC,EAGfrE,KAAK0D,aAAc,EACnB1D,KAAK4D,eAAgB,EACrB5D,KAAK6D,eAAgB,GAkCrB1B,EAAO,IAAIL,EAAKL,EAAiBI,EAAYF,GAG7C2C,EAAY,SAACnD,EAAGoD,GAClB,IACIC,EAAK1B,KAAK2B,KAAK,GACfC,EAAKnD,EAAEoD,IAAIxD,EAAEe,EAAIqC,EAAErC,GACnB0C,EAAKrD,EAAEoD,IAAIxD,EAAEkB,EAAIkC,EAAElC,GACvB,OAJS,GAIIqC,EAAKE,IAAOJ,EAAK,GAAU1B,KAAKE,IAAI0B,EAAIE,IAGvDrD,EAAEsD,MAAQ,WACRtD,EAAEuD,aAvKa,SAwKf3C,EAAKF,cACLE,EAAKS,oBACLT,EAAKiB,QAAQD,KAAKhB,EAAKI,OACvBJ,EAAKI,MAAMmB,aAAc,GAG3BnC,EAAEV,oBAAsB,SAASC,GAC/BY,EAAcZ,EAAOiB,SACrBH,EAAmBd,EAAOkB,cAAgB,IAC1CR,EAAcV,EAAOU,aAGvBD,EAAEwD,KAAO,WA8BP,GA7BAxD,EAAEyD,WAAW,KAGTtD,IAAgBD,KAGlBU,EAAO,IAAIL,EADXL,EAAkBC,EADlBG,EAzLa,IAyLaH,EAEmBC,IACxCM,cACLE,EAAKS,oBACLT,EAAKiB,QAAQD,KAAKhB,EAAKI,OACvBJ,EAAKI,MAAMmB,aAAc,EACzBnC,EAAEZ,sBAAsB,CAAEsE,QAAQ,KAIhCrD,IAAqBD,KAEvBQ,EAAO,IAAIL,EAAKL,EAAiBI,EADjCF,EAAuBC,IAElBK,cACLE,EAAKS,oBACLT,EAAKiB,QAAQD,KAAKhB,EAAKI,OACvBJ,EAAKI,MAAMmB,aAAc,EACzBnC,EAAEZ,sBAAsB,CAAEsE,QAAQ,KAIpC9C,EAAKO,eAGDlB,GAAeW,EAAKiB,QAAQ8B,OAAS,EAAG,CAC1C3D,EAAEZ,sBAAsB,CAAEwE,QAAS,2BAInC,IADA,IAAIC,EAAkB,EACbvC,EAAI,EAAGA,EAAIV,EAAKiB,QAAQ8B,OAAQrC,IACnCV,EAAKiB,QAAQP,GAAGoB,EAAI9B,EAAKiB,QAAQgC,GAAiBnB,IACpDmB,EAAkBvC,GAKtB,IAAIwC,EAAclD,EAAKiB,QAAQgC,GAa/B,GAVAjD,EAAKiB,QAAUjB,EAAKiB,QAAQkC,OAC1B,SAACC,EAAOC,GAAR,OAAkBA,IAAUJ,IAE9BC,EAAY3B,aAAc,EAG1BvB,EAAKkB,UAAUF,KAAKkC,GACpBA,EAAYzB,eAAgB,EAGxByB,IAAgBlD,EAAKK,IAAK,CAE5BhB,GAAc,EAGd,IAAIiE,EAAeJ,EAEnB,IADAlD,EAAKmB,YAAYH,KAAKsC,GACfA,EAAarB,SAClBjC,EAAKmB,YAAYH,KAAKsC,EAAarB,SACnCqB,EAAeA,EAAarB,QAI9B,IAAK,IAAIvB,EAAI,EAAGA,EAAIV,EAAKmB,YAAY4B,OAAQrC,IAC3CV,EAAKmB,YAAYT,GAAGgB,eAAgB,EAItCtC,EAAEZ,sBAAsB,CACtBa,YAAaA,EACbyD,QAAQ,EACRE,QAAS,gCAQb,IAHA,IAAIjC,EAAYmC,EAAYnC,UAGnBL,EAAI,EAAGA,EAAIK,EAAUgC,OAAQrC,IAEpC,IAAKV,EAAKkB,UAAUqC,SAASxC,EAAUL,IAAK,CAE1C,IAAI8C,EACFN,EAAYnB,EAAII,EAAUpB,EAAUL,GAAIwC,GACtCO,GAAe,EAEfzD,EAAKiB,QAAQsC,SAASxC,EAAUL,IAG9B8C,EAAkBzC,EAAUL,GAAGqB,IACjChB,EAAUL,GAAGqB,EAAIyB,EACjBC,GAAe,IAIjB1C,EAAUL,GAAGqB,EAAIyB,EACjBC,GAAe,EACfzD,EAAKiB,QAAQD,KAAKD,EAAUL,IAC5BK,EAAUL,GAAGa,aAAc,GAIzBkC,IACF1C,EAAUL,GAAGsB,EAAIG,EAAUpB,EAAUL,GAAIV,EAAKK,KAC9CU,EAAUL,GAAGoB,EAAIf,EAAUL,GAAGqB,EAAIhB,EAAUL,GAAGsB,EAC/CjB,EAAUL,GAAGuB,QAAUiB,SAKpB7D,GAAuC,IAAxBW,EAAKiB,QAAQ8B,SAErC1D,GAAc,EAGdD,EAAEZ,sBAAsB,CACtBa,aAAcA,EACdyD,QAAQ,EACRE,QAAS,gCCpNFU,cAxFb,SAAAA,EAAYjG,GAAO,IAAAC,EAAA,OAAAC,OAAAC,EAAA,EAAAD,CAAAE,KAAA6F,IACjBhG,EAAAC,OAAAG,EAAA,EAAAH,CAAAE,KAAAF,OAAAI,EAAA,EAAAJ,CAAA+F,GAAA1F,KAAAH,KAAMJ,KAkBRkG,eAAiB,SAAAC,GAAK,OACpBlG,EAAKmG,SAAS,CACZjE,SAAUgE,EAAME,OAAOV,MACvB/D,aAAa,EACb2D,QAAS,yBAvBMtF,EA2BnBqG,oBAAsB,SAAAH,GAAK,OACzBlG,EAAKmG,SAAS,CACZhE,cAAe+D,EAAME,OAAOV,MAC5B/D,aAAa,EACb2D,QAAS,yBA/BMtF,EAmCnBsG,aAAe,WACbtG,EAAKmG,SAAS,CACZxE,aAAc3B,EAAKuG,MAAM5E,YACzB2D,QAAS,yBAtCMtF,EA0CnBwG,YAAc,SAACC,EAAU1F,GAAX,OAAwBf,EAAKmG,SAASM,EAAU1F,IAxC5Df,EAAKuG,MAAQ,CAEXrE,SAAU,GAEVC,cAAe,GAEfR,aAAa,EAEbyD,QAAQ,EAERE,QAAS,sBAEToB,YAAa9F,GAdEZ,wEA6CjB,OACEqB,EAAAC,EAAAC,cAAA,WACEF,EAAAC,EAAAC,cAAA,wCACAF,EAAAC,EAAAC,cAAA,qCACAF,EAAAC,EAAAC,cAACoF,EAAD,CACE/F,OAAQT,KAAKoG,MAAMG,YACnBzF,OAAQ,CACNiB,SAAU/B,KAAKoG,MAAMrE,SACrBC,cAAehC,KAAKoG,MAAMpE,cAC1BR,YAAaxB,KAAKoG,MAAM5E,aAE1BZ,SAAUZ,KAAKqG,cAEjBnF,EAAAC,EAAAC,cAAA,mBAAWpB,KAAKoG,MAAMjB,SACtBjE,EAAAC,EAAAC,cAAA,uCACoBpB,KAAKoG,MAAMrE,SAD/B,MAC4C/B,KAAKoG,MAAMrE,UAEvDb,EAAAC,EAAAC,cAAA,SACEqF,KAAK,QACLC,aAAc1G,KAAKoG,MAAMrE,SACzBiB,IAAI,IACJD,IAAI,MACJ4D,KAAK,IACLC,QAAS5G,KAAK8F,iBAEhB5E,EAAAC,EAAAC,cAAA,gDAAoBpB,KAAKoG,MAAMpE,cAA/B,KACAd,EAAAC,EAAAC,cAAA,SACEqF,KAAK,QACLC,aAAc1G,KAAKoG,MAAMpE,cACzBgB,IAAI,IACJD,IAAI,MACJ4D,KAAK,IACLC,QAAS5G,KAAKkG,sBAEhBhF,EAAAC,EAAAC,cAAA,WACAF,EAAAC,EAAAC,cAAA,UAAQyF,QAAS7G,KAAKmG,aAAcW,SAAU9G,KAAKoG,MAAMnB,QACrDjF,KAAKoG,MAAM5E,YAAyB,eAAX,kBAlFnBF,aCAlByF,IAASC,OAAO9F,EAAAC,EAAAC,cAAC6F,EAAD,MAASC,SAASC,eAAe","file":"static/js/main.953a0c11.chunk.js","sourcesContent":["import React, { Component } from \"react\";\r\nimport p5 from \"p5\";\r\n\r\nclass P5Wrapper extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.wrapper = React.createRef();\r\n  }\r\n\r\n  componentDidMount() {\r\n    this.canva = new p5(this.props.sketch, this.wrapper.current);\r\n    this.canva.customCallbackHandler = this.props.callback;\r\n    if (this.canva.customRedrawHandler) {\r\n      this.canva.customRedrawHandler(this.props.values);\r\n    }\r\n  }\r\n\r\n  componentDidUpdate(prevProps) {\r\n    if (this.props.sketch !== prevProps.sketch) {\r\n      this.canva.remove();\r\n      this.canvas = new p5(this.props.sketch, this.wrapper);\r\n      this.canva.customCallbackHandler = this.props.callback;\r\n    }\r\n    if (this.canva.customRedrawHandler) {\r\n      this.canva.customRedrawHandler(this.props.values);\r\n    }\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    this.canva.remove();\r\n  }\r\n\r\n  render() {\r\n    return <div ref={this.wrapper} />;\r\n  }\r\n}\r\n\r\nexport default P5Wrapper;\r\n","export default function sketch(p) {\r\n  // Wielkość okna\r\n  let windowSize = 600;\r\n\r\n  // Kontrola algorytmu\r\n  let isSearching = false;\r\n\r\n  // Ustawienia siatki\r\n  let defaultGridSize = 20;\r\n  let currnetGridSize = defaultGridSize;\r\n  let newGridSize = 0;\r\n\r\n  // Ustawienia przeszkód\r\n  let defaultWallFrequency = 0.2;\r\n  let currentWallFrequency = defaultWallFrequency;\r\n  let newWallFrequency = 0;\r\n\r\n  // Wielkość pola\r\n  let squareSize = windowSize / currnetGridSize;\r\n\r\n  // Definicja siatki\r\n  class Grid {\r\n    constructor(gridSize, squareSize, wallFrequency) {\r\n      this.gridSize = gridSize;\r\n      this.squareSize = squareSize;\r\n      this.wallFrequency = wallFrequency;\r\n\r\n      this.grid = new Array(gridSize);\r\n\r\n      // Listy pół potrzebne do działania algorytmu\r\n      this.openSet = [];\r\n      this.closedSet = [];\r\n      this.optimalPath = [];\r\n    }\r\n\r\n    // Utwórz stosowną strukturę siatki\r\n    createNodes = () => {\r\n      for (let x = 0; x < this.gridSize; x++) {\r\n        this.grid[x] = new Array(this.gridSize);\r\n      }\r\n\r\n      for (let x = 0; x < this.gridSize; x++) {\r\n        for (let y = 0; y < this.gridSize; y++) {\r\n          this.grid[x][y] = new Node(x, y, this.squareSize, this.wallFrequency);\r\n        }\r\n      }\r\n\r\n      this.start = this.grid[0][0];\r\n      this.end = this.grid[this.gridSize - 1][this.gridSize - 1];\r\n\r\n      this.start.wall = 0;\r\n      this.end.wall = 0;\r\n    };\r\n\r\n    // Pokaż każde pole\r\n    displayNodes = () => {\r\n      for (let x = 0; x < this.gridSize; x++) {\r\n        for (let y = 0; y < this.gridSize; y++) {\r\n          this.grid[x][y].showNode();\r\n        }\r\n      }\r\n    };\r\n\r\n    // Dla każdego pola ustal sąsiadów\r\n    setNodesNeighbors = () => {\r\n      for (let x = 0; x < this.gridSize; x++) {\r\n        for (let y = 0; y < this.gridSize; y++) {\r\n          if (!this.grid[x][y].wall) {\r\n            for (\r\n              let i = Math.max(0, x - 1);\r\n              i <= Math.min(x + 1, this.gridSize - 1);\r\n              i++\r\n            ) {\r\n              for (\r\n                let j = Math.max(0, y - 1);\r\n                j <= Math.min(y + 1, this.gridSize - 1);\r\n                j++\r\n              ) {\r\n                if (i !== x || j !== y) {\r\n                  if (!this.grid[i][j].wall) {\r\n                    this.grid[x][y].neighbors.push(this.grid[i][j]);\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  // Definicja pola\r\n  class Node {\r\n    constructor(x, y, squareSize, wallFrequency) {\r\n      // Wielkość pola\r\n      this.size = squareSize;\r\n\r\n      // Pozycja pola w przestrzeni\r\n      this.x = x;\r\n      this.y = y;\r\n\r\n      // Czy pole jest przeszkodą\r\n      this.wall = false;\r\n\r\n      // Dodaj losowo przeszkodę\r\n      if (Math.random() < wallFrequency) {\r\n        this.wall = true;\r\n      }\r\n\r\n      // Wartości funckji dla algorytmu\r\n      this.f = 0;\r\n      this.g = 0;\r\n      this.h = 0;\r\n\r\n      // Sąsiedzi danego pola\r\n      this.neighbors = [];\r\n\r\n      // Poprzednie pole\r\n      this.partent = undefined;\r\n\r\n      // Do jakiego zbioru należy dane pole\r\n      this.isInOpenSet = false;\r\n      this.isInClosedSet = false;\r\n      this.isOptimalPath = false;\r\n    }\r\n\r\n    // Wyświetl pole\r\n    showNode = () => {\r\n      p.noStroke();\r\n      p.fill(255);\r\n\r\n      if (this.wall) {\r\n        p.fill(36);\r\n      }\r\n\r\n      if (this.isInOpenSet) {\r\n        p.fill(p.color(0, 255, 0, 80));\r\n      }\r\n\r\n      if (this.isInClosedSet) {\r\n        p.fill(p.color(255, 0, 0, 80));\r\n      }\r\n\r\n      if (this.isOptimalPath) {\r\n        p.fill(p.color(0, 0, 255, 80));\r\n      }\r\n\r\n      p.rect(\r\n        this.x * this.size,\r\n        this.y * this.size,\r\n        this.size - 1,\r\n        this.size - 1\r\n      );\r\n    };\r\n  }\r\n\r\n  // Utwórz nową siatkę\r\n  let grid = new Grid(currnetGridSize, squareSize, currentWallFrequency);\r\n\r\n  // Funcka zwracająca wartość heurystyki dla siatki, gdzie można poruszać się po przekątnych\r\n  let heuristic = (a, b) => {\r\n    let D1 = 1;\r\n    let D2 = Math.sqrt(2); // 1 - Chebyshev distance, sqrt(2) - octile distance\r\n    let dx = p.abs(a.x - b.x);\r\n    let dy = p.abs(a.y - b.y);\r\n    return D1 * (dx + dy) + (D2 - 2 * D1) * Math.min(dx, dy);\r\n  };\r\n\r\n  p.setup = function() {\r\n    p.createCanvas(windowSize, windowSize);\r\n    grid.createNodes();\r\n    grid.setNodesNeighbors();\r\n    grid.openSet.push(grid.start);\r\n    grid.start.isInOpenSet = true;\r\n  };\r\n\r\n  p.customRedrawHandler = function(values) {\r\n    newGridSize = values.gridSize;\r\n    newWallFrequency = values.wallFrequency / 100;\r\n    isSearching = values.isSearching;\r\n  };\r\n\r\n  p.draw = function() {\r\n    p.background(255);\r\n\r\n    // Utwórz nową siatkę jak zostanie zmieniony rozmiar\r\n    if (newGridSize !== currnetGridSize) {\r\n      squareSize = windowSize / newGridSize;\r\n      currnetGridSize = newGridSize;\r\n      grid = new Grid(currnetGridSize, squareSize, currentWallFrequency);\r\n      grid.createNodes();\r\n      grid.setNodesNeighbors();\r\n      grid.openSet.push(grid.start);\r\n      grid.start.isInOpenSet = true;\r\n      p.customCallbackHandler({ isDone: false });\r\n    }\r\n\r\n    // Utwórz nową siatkę jak zostanie zmieniona częstość występowania ścian\r\n    if (newWallFrequency !== currentWallFrequency) {\r\n      currentWallFrequency = newWallFrequency;\r\n      grid = new Grid(currnetGridSize, squareSize, currentWallFrequency);\r\n      grid.createNodes();\r\n      grid.setNodesNeighbors();\r\n      grid.openSet.push(grid.start);\r\n      grid.start.isInOpenSet = true;\r\n      p.customCallbackHandler({ isDone: false });\r\n    }\r\n\r\n    // Wyświetl obecny stan siatki\r\n    grid.displayNodes();\r\n\r\n    // Szukaj rozwiązania - implementacja algorytmu A*\r\n    if (isSearching && grid.openSet.length > 0) {\r\n      p.customCallbackHandler({ message: \"Szuka rozwiązania\" });\r\n\r\n      // Znajdz pole w zbiorze otwartym, które ma najleszą wartość funkcji F\r\n      let bestFScoreIndex = 0;\r\n      for (let i = 0; i < grid.openSet.length; i++) {\r\n        if (grid.openSet[i].f < grid.openSet[bestFScoreIndex].f) {\r\n          bestFScoreIndex = i;\r\n        }\r\n      }\r\n\r\n      // Ustaw obence pole jako to, które ma najleszą wartość funkcji F\r\n      let currentNode = grid.openSet[bestFScoreIndex];\r\n\r\n      // Usuń obecne pole ze zbioru otwartego\r\n      grid.openSet = grid.openSet.filter(\r\n        (value, index) => index !== bestFScoreIndex\r\n      );\r\n      currentNode.isInOpenSet = false;\r\n\r\n      // Dodaj obecne pole do zbioru zamkniętego\r\n      grid.closedSet.push(currentNode);\r\n      currentNode.isInClosedSet = true;\r\n\r\n      // Zakończ działanie algorytu jeżeli obecne pole jest polem końcowym\r\n      if (currentNode === grid.end) {\r\n        // Przerwij szukanie\r\n        isSearching = false;\r\n\r\n        // Zbuduj optymalną scieżke rozwiązania\r\n        let temporalNode = currentNode;\r\n        grid.optimalPath.push(temporalNode);\r\n        while (temporalNode.partent) {\r\n          grid.optimalPath.push(temporalNode.partent);\r\n          temporalNode = temporalNode.partent;\r\n        }\r\n\r\n        // Pokoloruj optymalną scieżke rozwiązania\r\n        for (let i = 0; i < grid.optimalPath.length; i++) {\r\n          grid.optimalPath[i].isOptimalPath = true;\r\n        }\r\n\r\n        // Przekaż informacje o wykonanym algorytmie do React\r\n        p.customCallbackHandler({\r\n          isSearching: isSearching,\r\n          isDone: true,\r\n          message: \"Znaleziono rozwiązanie\"\r\n        });\r\n      }\r\n\r\n      // Utwórz kopię listy sąsiadów dla obecnego pola - dla czytelności rozwiązania\r\n      let neighbors = currentNode.neighbors;\r\n\r\n      // Sprawdź sąsiadów obecnego pola\r\n      for (let i = 0; i < neighbors.length; i++) {\r\n        // Sprawdż czy obecnie sprawdzany sąsiad nie należy do zbioru zamkniętego - jeżeli należy to zignoruj\r\n        if (!grid.closedSet.includes(neighbors[i])) {\r\n          // Oblicz wartość funkcji G (odległość) od startu do sprawdzanego sąsiada\r\n          let temporaryGScore =\r\n            currentNode.g + heuristic(neighbors[i], currentNode);\r\n          let isPathBetter = false;\r\n          // Sprawdż czy obecnie sprawdzany sąsiad jest już w zbiorze otwartym\r\n          if (grid.openSet.includes(neighbors[i])) {\r\n            // Jeżeli jest w zbiorze otwartym i wartość funkcji G dla tego pola jest większa od tymczasowej wartośći funkcji G\r\n            // to ustaw wartość funkcji G dla tego pola na wartość tymszasową i uznaj że jest to lepsza ścieżka\r\n            if (temporaryGScore < neighbors[i].g) {\r\n              neighbors[i].g = temporaryGScore;\r\n              isPathBetter = true;\r\n            }\r\n            // Jeżeli nie jest w zbiorze otwartym to go dodaj i przyporządkuj mu wartość G, jest to lepsza ścieżka\r\n          } else {\r\n            neighbors[i].g = temporaryGScore;\r\n            isPathBetter = true;\r\n            grid.openSet.push(neighbors[i]);\r\n            neighbors[i].isInOpenSet = true;\r\n          }\r\n          // Jeżeli na tej podstawie odnalezione lepszą ścieżkę to oblicz heurystykę dla tego sąsiada i końca, oblicz wartość funkcji F\r\n          // Przypisz do tego pola, pole poprzednie jako pole, w celu ustalenia najlepszej ścieżki\r\n          if (isPathBetter) {\r\n            neighbors[i].h = heuristic(neighbors[i], grid.end);\r\n            neighbors[i].f = neighbors[i].g + neighbors[i].h;\r\n            neighbors[i].partent = currentNode;\r\n          }\r\n        }\r\n      }\r\n      // Jeżeli nie ma już pól w zbiorze otwartym a nie dotarliśmy do końca, to zadanie nie ma roziązania\r\n    } else if (isSearching && grid.openSet.length === 0) {\r\n      // Przerwij szukanie\r\n      isSearching = false;\r\n\r\n      // Przekaż informacje o wykonanym algorytmie do React\r\n      p.customCallbackHandler({\r\n        isSearching: !isSearching,\r\n        isDone: true,\r\n        message: \"Brak rozwiązania\"\r\n      });\r\n    }\r\n  };\r\n}\r\n","import React, { Component } from \"react\";\nimport P5Wrapper from \"./P5Wrapper\";\n\nimport sketch from \"./sketches/sketch\";\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      // Wielkość siatki\n      gridSize: 20,\n      // Częstość występowania przeszkód\n      wallFrequency: 20,\n      // Czy algorytm wyszukuje rozwiązania\n      isSearching: false,\n      // Czy algorytm znalazł rozwiąznie\n      isDone: false,\n      // Wiadomość do wyświetlenia\n      message: \"Rozpocznij szukanie\",\n      // Zaimportowany sketch\n      stateSketch: sketch\n    };\n  }\n\n  // Funckja wywoływana przy zmianie wielkości siatki\n  gridSizeChange = event =>\n    this.setState({\n      gridSize: event.target.value,\n      isSearching: false,\n      message: \"Rozpocznij szukanie\"\n    });\n\n  // Funckja wywoływana przy zmianie częstości występowania przeszkód\n  wallFrequencyChange = event =>\n    this.setState({\n      wallFrequency: event.target.value,\n      isSearching: false,\n      message: \"Rozpocznij szukanie\"\n    });\n\n  // Funkcjka uruchamiająca i zatrzymująca algorytm\n  toggleSearch = () => {\n    this.setState({\n      isSearching: !this.state.isSearching,\n      message: \"Rozpocznij szukanie\"\n    });\n  };\n\n  stateChange = (newState, callback) => this.setState(newState, callback);\n\n  render() {\n    return (\n      <div>\n        <h1>Implementacja algorytmu A*</h1>\n        <h2>Metody metaheurystyczne</h2>\n        <P5Wrapper\n          sketch={this.state.stateSketch}\n          values={{\n            gridSize: this.state.gridSize,\n            wallFrequency: this.state.wallFrequency,\n            isSearching: this.state.isSearching\n          }}\n          callback={this.stateChange}\n        />\n        <h2>Stan: {this.state.message}</h2>\n        <p>\n          Wielkość siatki: {this.state.gridSize} x {this.state.gridSize}\n        </p>\n        <input\n          type=\"range\"\n          defaultValue={this.state.gridSize}\n          min=\"5\"\n          max=\"100\"\n          step=\"5\"\n          onInput={this.gridSizeChange}\n        />\n        <p>Częstość ścian: {this.state.wallFrequency}%</p>\n        <input\n          type=\"range\"\n          defaultValue={this.state.wallFrequency}\n          min=\"0\"\n          max=\"100\"\n          step=\"1\"\n          onInput={this.wallFrequencyChange}\n        />\n        <br />\n        <button onClick={this.toggleSearch} disabled={this.state.isDone}>\n          {!this.state.isSearching ? \"SZUKAJ\" : \"ZAKOŃCZ\"}\n        </button>\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}